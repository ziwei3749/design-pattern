# 设计原则

目录

-   一、何为设计？
-   二、五大设计原则 solid
-   三、从设计到模式，设计和模式要分开。设计是设计原则，模式是 23 种模式
-   四、介绍 23 种设计模式

## 何为设计？

-   设计即按照一种「思路」来实现功能
-   功能相同，可以有不同的设计方案来实现
-   伴随着需求增加，设计的作用才能体现出来（需求必定不断的变化）

从《UNIX/LINUX 设计哲学》学习，到底什么是设计，有哪些设计准则

-   准则 1： 小即是美
-   准则 2： 让每个程序只做好一件事
-   准则 3： 快速建立原型
-   准则 4： 舍弃高效率，提高可以复用性 （效率和复用性的取舍）
-   准则 5： 采用纯文本来存储数据。（效率和可读性的取舍）
-   准则 6： 充分利用软件的杠杆效应 （软件复用）
-   准则 7： 使用 shell 脚本来提高杠杆效应和复用性
-   准则 8： 避免强制性的用户界面
-   准则 9： 让每一个程序都成为过滤器 （类似于准则 2）

小准则

-   允许用户定制环境，允许配置。
-   尽量让操作系统内核小而轻量化
-   使用「小写字母」并尽量简短
-   沉默是金
-   各个部分之和，大于整体
-   寻求 90%的解决方案，100 个人使用的我的产品，我只满足 90 个人用的舒服就行。 20%的精力解决 80%的需求，不必追求完美

> 演示: 沉默是金 + 让每一个程序成为过滤器

ls 就是过滤器

如果没有就是输出「空」，而不是输出 「no files」

这样如果你去查看当前 ls 的数量时，就是变成 1 了，就有 bug 了

所以设计成输出「空」，而不是输出 「no files」，这个就是沉默是金

## 五大设计原则 solid

-   1.单一职责原则
-   2.开放封闭原则 （多拓展开放，对修改封闭）
-   3.李氏置换原则 （所有父类出现的地方，子类都能出现）
-   4.接口独立原则 （和单一职责原则类似，但是它是专门针对接口的，但是前端里用的也不多）
-   5.依赖倒置原则（面向接口编程） （编程要依赖于抽象和接口）

> 1.单一职责原则

一个程序只做好一件事

如果功能过于复杂就拆分开，每一个部分保持独立，函数不超过 5 行

> 2.开放封闭原则

比如你想增加需求时，如果你是拓展新代码，之前的代码不用动

这个是最好的，对拓展开放，对修改封闭。

> 3.李氏置换原则

-   子类能覆盖父类
-   父类能出现的地方子类就能出现
-   JS 中使用较少，弱类型 & 继承使用较少

> 4.接口独立原则

-   保持接口的单一独立，避免出现「胖接口」

> 5.依赖倒置原则 （面向接口编程）

-   面向接口编程。我依赖于抽象，而不依赖于具体代码
-   使用者只关注接口，不用关注具体类的实现

我们具体的代码的代码，抽象成接口,这样写代码的人，调用代码的人，都只关注接口。

```
就像，后端只需要告诉我状态，不用关注我拿这个状态做什么逻辑。

显示也好、隐藏也好，或者高亮还是删除也好，后端不用管。

前端和后端，都只依赖这个接口
```

5 大设计原则中，我觉得这 3 个用多，体会深

-   单一职责原则
-   开放封闭原则
-   面向接口编程

这 2 个原则， 我个人体会要少一点，可能也跟 JS 语言有关系

-   李氏置换原则
-   接口独立原则

> Promise 举例说明，单一职责和开放封闭原则

-   「单一职责原则」：每一个 then 中只做好一件事情
-   「开放封闭原则」： 如果有新需求，拓展 then

## 简介 --- 从设计到模式，设计和模式要分开。设计是设计原则，模式是 23 种模式

设计和模式是 2 个次。

如果设计原则和 23 种模式，让你选一个学习。

肯定是先学习设计原则。模式是代码套路，在某种场景下的套路，而且别人总结出来的

-   先了解设计原则

-   模式是 23 种设计模式。设计原则理解之后，看看经典的几个模式就好了

## 23 种设计模式

设计原则有 5 大设计原则

23 种模式也是有分类的

-   创建型： 对象应该如何创建出来
-   组合型： 我们这些类，应该如何组合搭配
-   行为型： 有一些模式，包含了常见的行为

> 创建型

-   工厂模式 （工厂方法模式、抽象工厂模式、建造者模式）
-   单例模式
-   原型模式

> 结构型

-   适配器模式
-   装饰器模式
-   代理模式
-   外观模式

优先级偏低的

-   桥接模式
-   组合模式
-   享元模式

> 行为型

-   策略模式
-   模板方法模式
-   **观察者模式**
-   **迭代器模式**
-   职责连模式
-   命名模式
-   备忘录模式
-   **状态模式**
-   访问者模式
-   中介者模式
-   解释器模式

前端常用的设计模式，详细学习
前端不常使用的设计模式，了解慨念为主。

## 如何学习

课程如何讲解

-   介绍和生活例子
-   画 UML 类图，写 demo 代码
-   结合经典应用场景，学习设计模式在实际开发中的使用

个人如何学习

-   明白每一个设计的道理和用意
-   通过经典的应用场景，好好体会
-   自己编码时多思考，尽量模仿

## 面试举例 1：

-   打车时，可以打专车或者快车，任何车都有车牌号和名称。
-   不同车的价格不同，快车每公里 1 元，专车每公里 2 元
-   行程开始时，显示车辆信息
-   行程结束时，显示打车金额（假定车程 5 公里）

```js
class Car {
    constructor(id, name, price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    startDrive() {
        console.log(`车牌号: ${this.id} / 车牌名称: ${this.name}`);
    }

    endDrive() {
        console.log(`打车金额: ${5 * this.price}`);
    }
}

class QuickCar extends Car {
    constructor(id, name) {
        super(id, name, 1);
    }
}

class OneCar extends Car {
    constructor(id, name) {
        super(id, name, 2);
    }
}

let quickCar1 = new QuickCar("京00666", "快车");
let oneCar1 = new OneCar("冀11111", "专车");

quickCar1.startDrive();
quickCar1.endDrive();

oneCar1.startDrive();
oneCar1.endDrive();

```

参考答案

Car和Trip可以抽象出来
```js

class Car {
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }

}

class Trip {
    constructor(car) {
        this.car = car
    }

    start() {
        console.log(`车牌号： ${this.car.id} 车名称： ${this.car.name}`);
    }

    end() {
        console.log(`打车金额: ${5 * this.car.price}`);
    }
}

class QuickCar extends Car {
    constructor(id, name) {
        super( id, name );
        this.price = 1
    }
}

class OneCar extends Car {
    constructor(id, name) {
        super( id, name );
        this.price = 2
    }
}
let car = new QuickCar( 100, '桑塔纳' )
let trip = new Trip( car )

trip.start()
trip.end()

```


# ## 面试举例 2：

- 某停车场，分3层，每层100车位
- 每一个车位都能监控到车辆的驶入和离开
- 车辆进入前，显示每层的空余车位数量
- 车辆进入时，摄像头可以识别车牌号和时间
- 车辆出来时，出口显示器显示车牌号和停车时长

问：画出UML类图

我的答案
```js
class Parking {
    constructor(){
        this.cengshu = 3
        tiis.chwei = 100
    }

    add(){

    }

    sub(){

    }

    getNumber(cengshu){

    }

    
}

class car {
    constructor(number){
        this.number = number
        this.time = null

    }

    before(cengshu){
        new Parking(this,cengshu).getNumber()
    }

    enter(number){
        this.enterTime = new Date()
        console.log(number,new Date())
    }

    goOut(){
        console.log(number,new Date() - this.time) 
    }
    
}

```


参考答案

可以划分出4个类

class 停车场类 : 显示每层的空余车位数量

class 层类 : 显示该层的空余车位数量

class 车位类  ：是否为空的状态属性 ， 驶入fn ， 离开fn

class 车类: 

class 摄像头类 : 输出车牌号、时间，存到停车场

class 出口显示器类： 显示车牌号、停车时长


